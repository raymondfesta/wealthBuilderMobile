import Foundation

/// Manages budget operations including reallocation, tracking, and goal contributions
@MainActor
class BudgetManager: ObservableObject {
    @Published var budgets: [Budget] = []
    @Published var goals: [Goal] = []
    @Published var allocationBuckets: [AllocationBucket] = []
    @Published var isProcessing = false
    @Published var error: Error?

    private let baseURL: String
    private var userId: String?

    init(baseURL: String = "http://localhost:3000", userId: String? = nil) {
        self.baseURL = baseURL
        self.userId = userId
        if let userId = userId {
            print("ðŸ‘¤ [BudgetManager] Init with user: \(userId.prefix(8))...")
        }
        loadFromCache()
    }

    // MARK: - User Session

    /// Returns user-scoped cache key. Falls back to base key if no user set.
    private func cacheKey(_ base: String) -> String {
        guard let userId = userId, !userId.isEmpty else { return base }
        return "user_\(userId)_\(base)"
    }

    /// Sets current user and reloads cache with user-scoped keys
    func setUserId(_ userId: String) {
        guard self.userId != userId else { return }
        print("ðŸ‘¤ [BudgetManager] Setting user: \(userId.prefix(8))...")
        self.userId = userId
        loadFromCache()
    }

    // MARK: - Cache Migration

    /// Migrates old global cache key to user-scoped key (one-time migration)
    private func migrateOldCacheKey(_ oldKey: String, to newKey: String) {
        guard UserDefaults.standard.data(forKey: newKey) == nil,
              let oldData = UserDefaults.standard.data(forKey: oldKey) else { return }
        print("ðŸ’¾ [BudgetManager Migration] Migrating \(oldKey) â†’ \(newKey)")
        UserDefaults.standard.set(oldData, forKey: newKey)
        UserDefaults.standard.removeObject(forKey: oldKey)
    }

    /// Migrates all old cache keys to user-scoped keys
    private func migrateOldCacheKeys() {
        guard userId != nil else { return }
        print("ðŸ’¾ [BudgetManager Migration] Checking for old cache keys...")
        migrateOldCacheKey("cached_budgets", to: cacheKey("budgets"))
        migrateOldCacheKey("cached_goals", to: cacheKey("goals"))
        migrateOldCacheKey("cached_allocation_buckets", to: cacheKey("allocation_buckets"))
    }

    // MARK: - Budget Operations

    /// Creates or updates budgets based on transaction history
    func generateBudgets(from transactions: [Transaction]) {
        print("ðŸ’° [BudgetManager] generateBudgets() called with \(transactions.count) transactions")
        print("ðŸ’° [BudgetManager] Current budgets count before generation: \(budgets.count)")

        isProcessing = true
        defer { isProcessing = false }

        // Generate budgets using pattern analyzer
        let generatedBudgets = SpendingPatternAnalyzer.generateBudgetsFromHistory(
            transactions: transactions,
            months: 3
        )

        print("ðŸ’° [BudgetManager] Analyzer generated \(generatedBudgets.count) budgets")

        // Update current month's budgets
        for newBudget in generatedBudgets {
            if let existingIndex = budgets.firstIndex(where: {
                $0.categoryName == newBudget.categoryName &&
                $0.month == Date().startOfMonth
            }) {
                // Update existing budget
                print("ðŸ’° [BudgetManager] Updating existing budget for \(newBudget.categoryName)")
                budgets[existingIndex].monthlyLimit = newBudget.monthlyLimit
                budgets[existingIndex].updatedAt = Date()
            } else {
                // Add new budget
                print("ðŸ’° [BudgetManager] Adding new budget for \(newBudget.categoryName)")
                budgets.append(newBudget)
            }
        }

        print("ðŸ’° [BudgetManager] Final budgets count after generation: \(budgets.count)")
        print("ðŸ’° [BudgetManager] Budget categories: \(budgets.map { $0.categoryName })")

        saveContext()
    }

    /// Updates spent amount for a budget when a transaction occurs
    func recordTransaction(_ transaction: Transaction) {
        // Only record actual expenses, not investments or transfers
        guard transaction.amount > 0,
              !TransactionAnalyzer.shouldExcludeFromBudget(transaction) else { return }

        let category = transaction.category.first ?? "Uncategorized"
        let currentMonth = Date().startOfMonth

        if let budgetIndex = budgets.firstIndex(where: {
            $0.categoryName == category && $0.month == currentMonth
        }) {
            budgets[budgetIndex].addSpending(transaction.amount)
            saveContext()
        } else {
            // Create new budget if none exists
            let newBudget = Budget(
                categoryName: category,
                monthlyLimit: transaction.amount * 5, // Rough estimate
                currentSpent: transaction.amount,
                isAutoGenerated: true
            )
            budgets.append(newBudget)
            saveContext()
        }
    }

    /// Reallocates budget from one category to another
    func reallocateBudget(
        from sourceBudget: Budget,
        to destinationCategory: String,
        amount: Double
    ) -> Bool {
        guard sourceBudget.remaining >= amount else {
            error = BudgetError.insufficientBudget
            return false
        }

        isProcessing = true
        defer { isProcessing = false }

        // Find or create destination budget
        let currentMonth = Date().startOfMonth

        if let destIndex = budgets.firstIndex(where: {
            $0.categoryName == destinationCategory && $0.month == currentMonth
        }) {
            // Increase destination budget limit
            budgets[destIndex].monthlyLimit += amount
            budgets[destIndex].updatedAt = Date()
        } else {
            // Create new budget with reallocated amount
            let newBudget = Budget(
                categoryName: destinationCategory,
                monthlyLimit: amount,
                isAutoGenerated: false
            )
            budgets.append(newBudget)
        }

        // Decrease source budget limit
        if let sourceIndex = budgets.firstIndex(where: { $0.id == sourceBudget.id }) {
            budgets[sourceIndex].monthlyLimit -= amount
            budgets[sourceIndex].updatedAt = Date()
        }

        saveContext()
        return true
    }

    /// Manually sets a budget limit for a category
    func setBudget(category: String, limit: Double) {
        let currentMonth = Date().startOfMonth

        if let index = budgets.firstIndex(where: {
            $0.categoryName == category && $0.month == currentMonth
        }) {
            budgets[index].monthlyLimit = limit
            budgets[index].isAutoGenerated = false
            budgets[index].updatedAt = Date()
        } else {
            let newBudget = Budget(
                categoryName: category,
                monthlyLimit: limit,
                isAutoGenerated: false
            )
            budgets.append(newBudget)
        }

        saveContext()
    }

    /// Resets all budgets for the new month
    func resetBudgetsForNewMonth() {
        let newMonth = Date().startOfMonth

        for budget in budgets {
            budget.resetForNewMonth(newMonth: newMonth)
        }

        saveContext()
    }

    // MARK: - Goal Operations

    /// Creates a new financial goal
    func createGoal(
        name: String,
        targetAmount: Double,
        targetDate: Date?,
        goalType: GoalType,
        priority: GoalPriority
    ) {
        let goal = Goal(
            name: name,
            targetAmount: targetAmount,
            targetDate: targetDate,
            goalType: goalType,
            priority: priority,
            iconName: goalType.defaultIcon,
            colorHex: goalType.defaultColor
        )

        goals.append(goal)
        saveContext()
    }

    /// Contributes money to a goal
    func contributeToGoal(_ goal: Goal, amount: Double) {
        guard let index = goals.firstIndex(where: { $0.id == goal.id }) else {
            error = BudgetError.goalNotFound
            return
        }

        isProcessing = true
        defer { isProcessing = false }

        goals[index].contribute(amount)

        // Check for milestone achievements
        let percent = goals[index].percentComplete
        if percent >= 25 && percent < 30 {
            scheduleMilestoneNotification(goal: goals[index], milestone: 25)
        } else if percent >= 50 && percent < 55 {
            scheduleMilestoneNotification(goal: goals[index], milestone: 50)
        } else if percent >= 75 && percent < 80 {
            scheduleMilestoneNotification(goal: goals[index], milestone: 75)
        } else if goals[index].isComplete {
            scheduleGoalCompletedNotification(goal: goals[index])
        }

        saveContext()
    }

    /// Withdraws money from a goal
    func withdrawFromGoal(_ goal: Goal, amount: Double) {
        guard let index = goals.firstIndex(where: { $0.id == goal.id }) else {
            error = BudgetError.goalNotFound
            return
        }

        isProcessing = true
        defer { isProcessing = false }

        goals[index].withdraw(amount)
        saveContext()
    }

    /// Deletes a goal
    func deleteGoal(_ goal: Goal) {
        if let index = goals.firstIndex(where: { $0.id == goal.id }) {
            goals.remove(at: index)
            saveContext()
        }
    }

    // MARK: - Quick Actions

    /// Handles a purchase confirmation action
    func confirmPurchase(
        amount: Double,
        category: String,
        merchantName: String
    ) {
        // Record the transaction against budget
        let currentMonth = Date().startOfMonth

        if let index = budgets.firstIndex(where: {
            $0.categoryName == category && $0.month == currentMonth
        }) {
            budgets[index].addSpending(amount)
            saveContext()

            // Could trigger analytics or logging here
            print("âœ“ Purchase confirmed: $\(amount) at \(merchantName)")
        }
    }

    /// Defers a purchase to next month
    func deferPurchase(
        amount: Double,
        category: String,
        merchantName: String
    ) {
        // Could add to a "deferred purchases" list for next month's planning
        print("â¸ï¸ Purchase deferred: $\(amount) at \(merchantName)")

        // Optionally schedule a reminder for next month
    }

    /// Transfers money between accounts (placeholder - would integrate with Plaid Transfer API)
    func transferMoney(
        fromAccount: BankAccount,
        toAccount: BankAccount,
        amount: Double
    ) async throws {
        // In production, this would call Plaid Transfer API
        // For now, just a placeholder

        isProcessing = true
        defer { isProcessing = false }

        // Simulate API call
        try await Task.sleep(nanoseconds: 1_000_000_000)

        print("ðŸ’¸ Transferred $\(amount) from \(fromAccount.name) to \(toAccount.name)")

        // Would update account balances here after successful transfer
    }

    // MARK: - Allocation Buckets

    /// Generates allocation buckets by calling the backend recommendation API
    func generateAllocationBuckets(
        monthlyIncome: Double,
        monthlyExpenses: Double,
        currentSavings: Double,
        totalDebt: Double,
        categoryBreakdown: [String: Double],
        transactions: [Transaction],
        accounts: [BankAccount]
    ) async throws {
        print("ðŸ’° [BudgetManager] Generating allocation buckets...")
        print("ðŸ’° [BudgetManager] Input: income=$\(monthlyIncome), expenses=$\(monthlyExpenses), savings=$\(currentSavings), debt=$\(totalDebt)")

        isProcessing = true
        defer { isProcessing = false }

        let endpoint = "\(baseURL)/api/ai/allocation-recommendation"

        guard let url = URL(string: endpoint) else {
            print("âŒ [BudgetManager] Invalid URL: \(endpoint)")
            throw BudgetError.invalidAllocationRequest
        }

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.timeoutInterval = 90 // AI requests can take longer, especially on physical devices with network latency

        // Build the request body matching backend API expectations
        let requestBody: [String: Any] = [
            "monthlyIncome": monthlyIncome,
            "monthlyExpenses": monthlyExpenses,
            "currentSavings": currentSavings,
            "totalDebt": totalDebt,
            "categoryBreakdown": categoryBreakdown
        ]

        request.httpBody = try JSONSerialization.data(withJSONObject: requestBody)

        print("ðŸ’° [BudgetManager] Calling \(endpoint)...")
        let (data, response) = try await URLSession.shared.data(for: request)

        guard let httpResponse = response as? HTTPURLResponse else {
            print("âŒ [BudgetManager] Invalid HTTP response")
            throw BudgetError.networkError
        }

        print("ðŸ’° [BudgetManager] Response status: \(httpResponse.statusCode)")

        guard httpResponse.statusCode == 200 else {
            if let responseStr = String(data: data, encoding: .utf8) {
                print("âŒ [BudgetManager] Error response: \(responseStr)")
            }
            throw BudgetError.allocationGenerationFailed
        }

        // Parse the response
        let decoder = JSONDecoder()
        let allocationResponse = try decoder.decode(AllocationResponse.self, from: data)

        print("ðŸ’° [BudgetManager] Successfully received allocation recommendations")

        // Convert API response to AllocationBucket objects
        var newBuckets: [AllocationBucket] = []

        // Essential Spending
        if let essential = allocationResponse.allocations.essentialSpending {
            let bucket = AllocationBucket(
                type: .essentialSpending,
                allocatedAmount: essential.amount,
                percentageOfIncome: essential.percentage,
                linkedCategories: essential.categories ?? [],
                explanation: essential.explanation
            )
            newBuckets.append(bucket)
            print("ðŸ’° [BudgetManager] Created Essential Spending bucket: $\(essential.amount) (\(essential.percentage)%)")
        }

        // Emergency Fund
        if let emergency = allocationResponse.allocations.emergencyFund {
            let bucket = AllocationBucket(
                type: .emergencyFund,
                allocatedAmount: emergency.amount,
                percentageOfIncome: emergency.percentage,
                linkedCategories: [], // Virtual bucket
                explanation: emergency.explanation,
                targetAmount: emergency.targetAmount,
                monthsToTarget: emergency.monthsToTarget
            )
            bucket.emergencyDurationOptions = emergency.durationOptions
            newBuckets.append(bucket)
            print("ðŸ’° [BudgetManager] Created Emergency Fund bucket: $\(emergency.amount) (\(emergency.percentage)%), target=$\(emergency.targetAmount ?? 0)")
        }

        // Discretionary Spending
        if let discretionary = allocationResponse.allocations.discretionarySpending {
            let bucket = AllocationBucket(
                type: .discretionarySpending,
                allocatedAmount: discretionary.amount,
                percentageOfIncome: discretionary.percentage,
                linkedCategories: discretionary.categories ?? [],
                explanation: discretionary.explanation
            )
            bucket.presetOptions = discretionary.presetOptions
            newBuckets.append(bucket)
            print("ðŸ’° [BudgetManager] Created Discretionary Spending bucket: $\(discretionary.amount) (\(discretionary.percentage)%)")
        }

        // Investments
        if let investments = allocationResponse.allocations.investments {
            let bucket = AllocationBucket(
                type: .investments,
                allocatedAmount: investments.amount,
                percentageOfIncome: investments.percentage,
                linkedCategories: [], // Virtual bucket
                explanation: investments.explanation
            )
            bucket.presetOptions = investments.presetOptions
            bucket.investmentProjection = investments.projection
            newBuckets.append(bucket)
            print("ðŸ’° [BudgetManager] Created Investments bucket: $\(investments.amount) (\(investments.percentage)%)")
        }

        // Debt Paydown (only if debt > $1000)
        if let debtPaydown = allocationResponse.allocations.debtPaydown {
            let bucket = AllocationBucket(
                type: .debtPaydown,
                allocatedAmount: debtPaydown.amount,
                percentageOfIncome: debtPaydown.percentage,
                linkedCategories: [],
                explanation: debtPaydown.explanation
            )
            bucket.presetOptions = debtPaydown.presetOptions
            newBuckets.append(bucket)
            print("ðŸ’° [BudgetManager] Created Debt Paydown bucket: $\(debtPaydown.amount) (\(debtPaydown.percentage)%)")
        }

        // Update published property
        self.allocationBuckets = newBuckets

        // Save to cache
        saveAllocationBucketsToCache()

        print("ðŸ’° [BudgetManager] Successfully generated \(newBuckets.count) allocation buckets")
        print("ðŸ’° [BudgetManager] Summary: \(allocationResponse.summary.basedOn)")
    }

    // MARK: - Analysis

    /// Gets budget summary for current month
    func getCurrentMonthSummary() -> BudgetSummary {
        let currentMonth = Date().startOfMonth
        let currentBudgets = budgets.filter { $0.month == currentMonth }

        let totalBudgeted = currentBudgets.map { $0.monthlyLimit }.reduce(0, +)
        let totalSpent = currentBudgets.map { $0.currentSpent }.reduce(0, +)
        let totalRemaining = currentBudgets.map { $0.remaining }.reduce(0, +)

        let overBudgetCategories = currentBudgets.filter { $0.isOverBudget }
        let onTrackCategories = currentBudgets.filter { !$0.isOverBudget }

        return BudgetSummary(
            totalBudgeted: totalBudgeted,
            totalSpent: totalSpent,
            totalRemaining: totalRemaining,
            percentUsed: totalBudgeted > 0 ? (totalSpent / totalBudgeted) * 100 : 0,
            overBudgetCount: overBudgetCategories.count,
            onTrackCount: onTrackCategories.count,
            daysRemaining: Date().daysRemainingInMonth
        )
    }

    /// Identifies which goals should be prioritized based on current financial state
    func recommendGoalPriority(disposableIncome: Double) -> [Goal] {
        // Sort by priority and completion percentage
        return goals
            .filter { $0.isActive && !$0.isComplete }
            .sorted { goal1, goal2 in
                // First by priority
                if goal1.priority.sortOrder != goal2.priority.sortOrder {
                    return goal1.priority.sortOrder < goal2.priority.sortOrder
                }
                // Then by how close to completion
                return goal1.percentComplete > goal2.percentComplete
            }
    }

    // MARK: - Private Helpers

    private func saveContext() {
        saveToCache()
    }

    private func saveToCache() {
        let encoder = JSONEncoder()
        if let budgetsData = try? encoder.encode(budgets) {
            UserDefaults.standard.set(budgetsData, forKey: cacheKey("budgets"))
        }
        if let goalsData = try? encoder.encode(goals) {
            UserDefaults.standard.set(goalsData, forKey: cacheKey("goals"))
        }
        saveAllocationBucketsToCache()
    }

    private func loadFromCache() {
        // Migrate old global cache keys to user-scoped keys (one-time)
        migrateOldCacheKeys()

        let decoder = JSONDecoder()
        if let budgetsData = UserDefaults.standard.data(forKey: cacheKey("budgets")),
           let budgets = try? decoder.decode([Budget].self, from: budgetsData) {
            self.budgets = budgets
            print("ðŸ’° [BudgetManager] Loaded \(budgets.count) budgets from cache")
        }
        if let goalsData = UserDefaults.standard.data(forKey: cacheKey("goals")),
           let goals = try? decoder.decode([Goal].self, from: goalsData) {
            self.goals = goals
            print("ðŸ’° [BudgetManager] Loaded \(goals.count) goals from cache")
        }
        loadAllocationBucketsFromCache()
    }

    private func saveAllocationBucketsToCache() {
        let encoder = JSONEncoder()
        if let data = try? encoder.encode(allocationBuckets) {
            UserDefaults.standard.set(data, forKey: cacheKey("allocation_buckets"))
            print("ðŸ’° [BudgetManager] Saved \(allocationBuckets.count) allocation buckets to cache")
        }
    }

    private func loadAllocationBucketsFromCache() {
        let decoder = JSONDecoder()
        if let data = UserDefaults.standard.data(forKey: cacheKey("allocation_buckets")),
           let buckets = try? decoder.decode([AllocationBucket].self, from: data) {
            self.allocationBuckets = buckets
            print("ðŸ’° [BudgetManager] Loaded \(buckets.count) allocation buckets from cache")
        }
    }

    private func scheduleMilestoneNotification(goal: Goal, milestone: Int) {
        Task {
            try? await NotificationService.shared.scheduleGoalMilestone(
                goalName: goal.name,
                percentComplete: Double(milestone)
            )
        }
    }

    private func scheduleGoalCompletedNotification(goal: Goal) {
        Task {
            try? await NotificationService.shared.scheduleGoalMilestone(
                goalName: goal.name,
                percentComplete: 100
            )
        }
    }
}

// MARK: - Supporting Types

struct BudgetSummary {
    let totalBudgeted: Double
    let totalSpent: Double
    let totalRemaining: Double
    let percentUsed: Double
    let overBudgetCount: Int
    let onTrackCount: Int
    let daysRemaining: Int

    var status: String {
        if percentUsed >= 100 {
            return "Over Budget"
        } else if percentUsed >= 90 {
            return "Near Limit"
        } else if percentUsed >= 75 {
            return "On Track (Caution)"
        } else {
            return "On Track"
        }
    }

    var dailyBudget: Double {
        guard daysRemaining > 0 else { return 0 }
        return totalRemaining / Double(daysRemaining)
    }
}

enum BudgetError: LocalizedError {
    case insufficientBudget
    case goalNotFound
    case budgetNotFound
    case invalidAmount
    case invalidAllocationRequest
    case networkError
    case allocationGenerationFailed

    var errorDescription: String? {
        switch self {
        case .insufficientBudget:
            return "Not enough budget available for this reallocation"
        case .goalNotFound:
            return "Goal not found"
        case .budgetNotFound:
            return "Budget not found"
        case .invalidAmount:
            return "Invalid amount specified"
        case .invalidAllocationRequest:
            return "Invalid allocation request parameters"
        case .networkError:
            return "Network connection failed"
        case .allocationGenerationFailed:
            return "Failed to generate allocation recommendations"
        }
    }
}

// MARK: - Allocation API Response Models

private struct AllocationResponse: Codable {
    let allocations: AllocationsData
    let summary: AllocationSummary
}

private struct AllocationsData: Codable {
    let essentialSpending: AllocationDetail?
    let emergencyFund: EmergencyFundAPIDetail?
    let discretionarySpending: AllocationDetail?
    let investments: InvestmentAPIDetail?
    let debtPaydown: DebtPaydownDetail?
}

private struct AllocationDetail: Codable {
    let amount: Double
    let percentage: Double
    let categories: [String]?
    let explanation: String
    let currentBalance: Double?
    let presetOptions: PresetOptions?
}

private struct EmergencyFundAPIDetail: Codable {
    let amount: Double
    let percentage: Double
    let targetAmount: Double?
    let monthsToTarget: Int?
    let explanation: String
    let currentBalance: Double?
    let durationOptions: [EmergencyFundDurationOption]?
}

private struct InvestmentAPIDetail: Codable {
    let amount: Double
    let percentage: Double
    let explanation: String
    let currentBalance: Double?
    let presetOptions: PresetOptions?
    let projection: InvestmentProjection?
}

private struct DebtPaydownDetail: Codable {
    let amount: Double
    let percentage: Double
    let totalDebt: Double?
    let highInterestDebt: Double?
    let averageAPR: Double?
    let explanation: String
    let presetOptions: PresetOptions?
    let payoffTimeline: PayoffTimeline?
}

private struct PayoffTimeline: Codable {
    let low: PayoffInfo
    let recommended: PayoffInfo
    let high: PayoffInfo
}

private struct PayoffInfo: Codable {
    let months: Int
    let interestSaved: Double
}

private struct AllocationSummary: Codable {
    let totalAllocated: Double
    let basedOn: String
    let includesDebtPaydown: Bool?
}
