import Foundation

/// Manages budget operations including reallocation, tracking, and goal contributions
@MainActor
class BudgetManager: ObservableObject {
    @Published var budgets: [Budget] = []
    @Published var goals: [Goal] = []
    @Published var isProcessing = false
    @Published var error: Error?

    init() {
        loadFromCache()
    }

    // MARK: - Budget Operations

    /// Creates or updates budgets based on transaction history
    func generateBudgets(from transactions: [Transaction]) {
        isProcessing = true
        defer { isProcessing = false }

        // Generate budgets using pattern analyzer
        let generatedBudgets = SpendingPatternAnalyzer.generateBudgetsFromHistory(
            transactions: transactions,
            months: 3
        )

        // Update current month's budgets
        for newBudget in generatedBudgets {
            if let existingIndex = budgets.firstIndex(where: {
                $0.categoryName == newBudget.categoryName &&
                $0.month == Date().startOfMonth
            }) {
                // Update existing budget
                budgets[existingIndex].monthlyLimit = newBudget.monthlyLimit
                budgets[existingIndex].updatedAt = Date()
            } else {
                // Add new budget
                budgets.append(newBudget)
            }
        }

        saveContext()
    }

    /// Updates spent amount for a budget when a transaction occurs
    func recordTransaction(_ transaction: Transaction) {
        guard transaction.amount > 0,
              transaction.bucketCategory == .expenses else { return }

        let category = transaction.category.first ?? "Uncategorized"
        let currentMonth = Date().startOfMonth

        if let budgetIndex = budgets.firstIndex(where: {
            $0.categoryName == category && $0.month == currentMonth
        }) {
            budgets[budgetIndex].addSpending(transaction.amount)
            saveContext()
        } else {
            // Create new budget if none exists
            let newBudget = Budget(
                categoryName: category,
                monthlyLimit: transaction.amount * 5, // Rough estimate
                currentSpent: transaction.amount,
                isAutoGenerated: true
            )
            budgets.append(newBudget)
            saveContext()
        }
    }

    /// Reallocates budget from one category to another
    func reallocateBudget(
        from sourceBudget: Budget,
        to destinationCategory: String,
        amount: Double
    ) -> Bool {
        guard sourceBudget.remaining >= amount else {
            error = BudgetError.insufficientBudget
            return false
        }

        isProcessing = true
        defer { isProcessing = false }

        // Find or create destination budget
        let currentMonth = Date().startOfMonth

        if let destIndex = budgets.firstIndex(where: {
            $0.categoryName == destinationCategory && $0.month == currentMonth
        }) {
            // Increase destination budget limit
            budgets[destIndex].monthlyLimit += amount
            budgets[destIndex].updatedAt = Date()
        } else {
            // Create new budget with reallocated amount
            let newBudget = Budget(
                categoryName: destinationCategory,
                monthlyLimit: amount,
                isAutoGenerated: false
            )
            budgets.append(newBudget)
        }

        // Decrease source budget limit
        if let sourceIndex = budgets.firstIndex(where: { $0.id == sourceBudget.id }) {
            budgets[sourceIndex].monthlyLimit -= amount
            budgets[sourceIndex].updatedAt = Date()
        }

        saveContext()
        return true
    }

    /// Manually sets a budget limit for a category
    func setBudget(category: String, limit: Double) {
        let currentMonth = Date().startOfMonth

        if let index = budgets.firstIndex(where: {
            $0.categoryName == category && $0.month == currentMonth
        }) {
            budgets[index].monthlyLimit = limit
            budgets[index].isAutoGenerated = false
            budgets[index].updatedAt = Date()
        } else {
            let newBudget = Budget(
                categoryName: category,
                monthlyLimit: limit,
                isAutoGenerated: false
            )
            budgets.append(newBudget)
        }

        saveContext()
    }

    /// Resets all budgets for the new month
    func resetBudgetsForNewMonth() {
        let newMonth = Date().startOfMonth

        for budget in budgets {
            budget.resetForNewMonth(newMonth: newMonth)
        }

        saveContext()
    }

    // MARK: - Goal Operations

    /// Creates a new financial goal
    func createGoal(
        name: String,
        targetAmount: Double,
        targetDate: Date?,
        goalType: GoalType,
        priority: GoalPriority
    ) {
        let goal = Goal(
            name: name,
            targetAmount: targetAmount,
            targetDate: targetDate,
            goalType: goalType,
            priority: priority,
            iconName: goalType.defaultIcon,
            colorHex: goalType.defaultColor
        )

        goals.append(goal)
        saveContext()
    }

    /// Contributes money to a goal
    func contributeToGoal(_ goal: Goal, amount: Double) {
        guard let index = goals.firstIndex(where: { $0.id == goal.id }) else {
            error = BudgetError.goalNotFound
            return
        }

        isProcessing = true
        defer { isProcessing = false }

        goals[index].contribute(amount)

        // Check for milestone achievements
        let percent = goals[index].percentComplete
        if percent >= 25 && percent < 30 {
            scheduleMilestoneNotification(goal: goals[index], milestone: 25)
        } else if percent >= 50 && percent < 55 {
            scheduleMilestoneNotification(goal: goals[index], milestone: 50)
        } else if percent >= 75 && percent < 80 {
            scheduleMilestoneNotification(goal: goals[index], milestone: 75)
        } else if goals[index].isComplete {
            scheduleGoalCompletedNotification(goal: goals[index])
        }

        saveContext()
    }

    /// Withdraws money from a goal
    func withdrawFromGoal(_ goal: Goal, amount: Double) {
        guard let index = goals.firstIndex(where: { $0.id == goal.id }) else {
            error = BudgetError.goalNotFound
            return
        }

        isProcessing = true
        defer { isProcessing = false }

        goals[index].withdraw(amount)
        saveContext()
    }

    /// Deletes a goal
    func deleteGoal(_ goal: Goal) {
        if let index = goals.firstIndex(where: { $0.id == goal.id }) {
            let goalToDelete = goals[index]
            goals.remove(at: index)

            saveContext()
        }
    }

    // MARK: - Quick Actions

    /// Handles a purchase confirmation action
    func confirmPurchase(
        amount: Double,
        category: String,
        merchantName: String
    ) {
        // Record the transaction against budget
        let currentMonth = Date().startOfMonth

        if let index = budgets.firstIndex(where: {
            $0.categoryName == category && $0.month == currentMonth
        }) {
            budgets[index].addSpending(amount)
            saveContext()

            // Could trigger analytics or logging here
            print("âœ“ Purchase confirmed: $\(amount) at \(merchantName)")
        }
    }

    /// Defers a purchase to next month
    func deferPurchase(
        amount: Double,
        category: String,
        merchantName: String
    ) {
        // Could add to a "deferred purchases" list for next month's planning
        print("â¸ï¸ Purchase deferred: $\(amount) at \(merchantName)")

        // Optionally schedule a reminder for next month
    }

    /// Transfers money between accounts (placeholder - would integrate with Plaid Transfer API)
    func transferMoney(
        fromAccount: BankAccount,
        toAccount: BankAccount,
        amount: Double
    ) async throws {
        // In production, this would call Plaid Transfer API
        // For now, just a placeholder

        isProcessing = true
        defer { isProcessing = false }

        // Simulate API call
        try await Task.sleep(nanoseconds: 1_000_000_000)

        print("ðŸ’¸ Transferred $\(amount) from \(fromAccount.name) to \(toAccount.name)")

        // Would update account balances here after successful transfer
    }

    // MARK: - Analysis

    /// Gets budget summary for current month
    func getCurrentMonthSummary() -> BudgetSummary {
        let currentMonth = Date().startOfMonth
        let currentBudgets = budgets.filter { $0.month == currentMonth }

        let totalBudgeted = currentBudgets.map { $0.monthlyLimit }.reduce(0, +)
        let totalSpent = currentBudgets.map { $0.currentSpent }.reduce(0, +)
        let totalRemaining = currentBudgets.map { $0.remaining }.reduce(0, +)

        let overBudgetCategories = currentBudgets.filter { $0.isOverBudget }
        let onTrackCategories = currentBudgets.filter { !$0.isOverBudget }

        return BudgetSummary(
            totalBudgeted: totalBudgeted,
            totalSpent: totalSpent,
            totalRemaining: totalRemaining,
            percentUsed: totalBudgeted > 0 ? (totalSpent / totalBudgeted) * 100 : 0,
            overBudgetCount: overBudgetCategories.count,
            onTrackCount: onTrackCategories.count,
            daysRemaining: Date().daysRemainingInMonth
        )
    }

    /// Identifies which goals should be prioritized based on current financial state
    func recommendGoalPriority(availableToSpend: Double) -> [Goal] {
        // Sort by priority and completion percentage
        return goals
            .filter { $0.isActive && !$0.isComplete }
            .sorted { goal1, goal2 in
                // First by priority
                if goal1.priority.sortOrder != goal2.priority.sortOrder {
                    return goal1.priority.sortOrder < goal2.priority.sortOrder
                }
                // Then by how close to completion
                return goal1.percentComplete > goal2.percentComplete
            }
    }

    // MARK: - Private Helpers

    private func saveContext() {
        saveToCache()
    }

    private func saveToCache() {
        let encoder = JSONEncoder()
        if let budgetsData = try? encoder.encode(budgets) {
            UserDefaults.standard.set(budgetsData, forKey: "cached_budgets")
        }
        if let goalsData = try? encoder.encode(goals) {
            UserDefaults.standard.set(goalsData, forKey: "cached_goals")
        }
    }

    private func loadFromCache() {
        let decoder = JSONDecoder()
        if let budgetsData = UserDefaults.standard.data(forKey: "cached_budgets"),
           let budgets = try? decoder.decode([Budget].self, from: budgetsData) {
            self.budgets = budgets
        }
        if let goalsData = UserDefaults.standard.data(forKey: "cached_goals"),
           let goals = try? decoder.decode([Goal].self, from: goalsData) {
            self.goals = goals
        }
    }

    private func scheduleMilestoneNotification(goal: Goal, milestone: Int) {
        Task {
            try? await NotificationService.shared.scheduleGoalMilestone(
                goalName: goal.name,
                percentComplete: Double(milestone)
            )
        }
    }

    private func scheduleGoalCompletedNotification(goal: Goal) {
        Task {
            try? await NotificationService.shared.scheduleGoalMilestone(
                goalName: goal.name,
                percentComplete: 100
            )
        }
    }
}

// MARK: - Supporting Types

struct BudgetSummary {
    let totalBudgeted: Double
    let totalSpent: Double
    let totalRemaining: Double
    let percentUsed: Double
    let overBudgetCount: Int
    let onTrackCount: Int
    let daysRemaining: Int

    var status: String {
        if percentUsed >= 100 {
            return "Over Budget"
        } else if percentUsed >= 90 {
            return "Near Limit"
        } else if percentUsed >= 75 {
            return "On Track (Caution)"
        } else {
            return "On Track"
        }
    }

    var dailyBudget: Double {
        guard daysRemaining > 0 else { return 0 }
        return totalRemaining / Double(daysRemaining)
    }
}

enum BudgetError: LocalizedError {
    case insufficientBudget
    case goalNotFound
    case budgetNotFound
    case invalidAmount

    var errorDescription: String? {
        switch self {
        case .insufficientBudget:
            return "Not enough budget available for this reallocation"
        case .goalNotFound:
            return "Goal not found"
        case .budgetNotFound:
            return "Budget not found"
        case .invalidAmount:
            return "Invalid amount specified"
        }
    }
}
