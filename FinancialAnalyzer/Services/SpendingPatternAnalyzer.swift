import Foundation

/// Analyzes spending patterns to generate budgets and detect anomalies
struct SpendingPatternAnalyzer {

    // MARK: - Auto-Generate Budgets

    /// Generates budget recommendations based on historical spending patterns
    static func generateBudgetsFromHistory(
        transactions: [Transaction],
        months: Int = 3
    ) -> [Budget] {
        print("ðŸ“Š [Budget Generation] Starting budget generation from \(transactions.count) total transactions")

        // Filter to last N months
        let cutoffDate = Calendar.current.date(byAdding: .month, value: -months, to: Date()) ?? Date()
        let recentTransactions = transactions.filter { $0.date >= cutoffDate && !$0.pending }
        print("ðŸ“Š [Budget Generation] Filtered to \(recentTransactions.count) transactions from last \(months) months (cutoff: \(cutoffDate))")

        // Group expenses by category
        var categorySpending: [String: [Double]] = [:]

        for transaction in recentTransactions {
            // Use the new classification helpers - exclude investment contributions and transfers
            guard transaction.amount > 0,
                  !TransactionAnalyzer.shouldExcludeFromBudget(transaction) else { continue }

            let category = transaction.category.first ?? "Uncategorized"
            categorySpending[category, default: []].append(transaction.amount)
        }

        print("ðŸ“Š [Budget Generation] Found \(categorySpending.keys.count) expense categories")
        for (category, amounts) in categorySpending {
            let total = amounts.reduce(0, +)
            let avg = total / Double(months)
            print("ðŸ“Š [Budget Generation]   - \(category): \(amounts.count) transactions, $\(String(format: "%.2f", total)) total, $\(String(format: "%.2f", avg))/month avg")
        }

        // Create budgets with 10% buffer above average spending
        var budgets: [Budget] = []
        let currentMonth = Date().startOfMonth

        for (category, amounts) in categorySpending {
            let totalSpent = amounts.reduce(0, +)
            let avgMonthlySpending = totalSpent / Double(months)

            // Add 10% buffer to allow for flexibility
            let suggestedLimit = avgMonthlySpending * 1.1

            // Only create budgets for categories with meaningful spending (>$10/month avg)
            // Note: Lowered from $20 to $10 for MVP to work better with Plaid sandbox data
            if suggestedLimit > 10 {
                let budget = Budget(
                    categoryName: category,
                    monthlyLimit: suggestedLimit,
                    month: currentMonth,
                    isAutoGenerated: true
                )
                budgets.append(budget)
                print("ðŸ“Š [Budget Generation] âœ… Created budget for \(category): $\(String(format: "%.2f", suggestedLimit))/month")
            } else {
                print("ðŸ“Š [Budget Generation] â­ï¸  Skipped \(category): $\(String(format: "%.2f", suggestedLimit))/month (below $10 threshold)")
            }
        }

        print("ðŸ“Š [Budget Generation] Final result: Generated \(budgets.count) budgets")
        return budgets.sorted { $0.monthlyLimit > $1.monthlyLimit }
    }

    // MARK: - Spending Patterns

    /// Analyzes spending patterns for a specific merchant
    static func merchantPattern(
        merchantName: String,
        transactions: [Transaction]
    ) -> MerchantPattern {
        let merchantTransactions = transactions.filter {
            $0.merchantName?.lowercased() == merchantName.lowercased() ||
            $0.name.lowercased().contains(merchantName.lowercased())
        }

        guard !merchantTransactions.isEmpty else {
            return MerchantPattern(
                merchantName: merchantName,
                averageAmount: 0,
                frequency: 0,
                lastVisit: nil,
                totalSpent: 0
            )
        }

        let amounts = merchantTransactions.map { $0.amount }
        let totalSpent = amounts.reduce(0, +)
        let avgAmount = totalSpent / Double(amounts.count)
        let lastVisit = merchantTransactions.map { $0.date }.max()

        // Calculate monthly frequency
        let oldestDate = merchantTransactions.map { $0.date }.min() ?? Date()
        let monthsBetween = Calendar.current.dateComponents([.month], from: oldestDate, to: Date()).month ?? 1
        let frequency = Double(merchantTransactions.count) / Double(max(monthsBetween, 1))

        return MerchantPattern(
            merchantName: merchantName,
            averageAmount: avgAmount,
            frequency: frequency,
            lastVisit: lastVisit,
            totalSpent: totalSpent
        )
    }

    /// Detects spending category patterns (day of week, time of month, etc.)
    static func categoryPattern(
        category: String,
        transactions: [Transaction]
    ) -> CategoryPattern {
        let categoryTransactions = transactions.filter {
            $0.category.first?.lowercased() == category.lowercased()
        }

        guard !categoryTransactions.isEmpty else {
            return CategoryPattern(
                categoryName: category,
                averageMonthly: 0,
                peakSpendingDay: nil,
                typicalRange: 0...0,
                trend: .stable
            )
        }

        // Calculate monthly average
        let totalSpent = categoryTransactions.map { $0.amount }.reduce(0, +)
        let months = monthsSpanned(transactions: categoryTransactions)
        let avgMonthly = totalSpent / Double(max(months, 1))

        // Find peak spending day (day of month)
        var daySpending: [Int: Double] = [:]
        for transaction in categoryTransactions {
            let day = Calendar.current.component(.day, from: transaction.date)
            daySpending[day, default: 0] += transaction.amount
        }
        let peakDay = daySpending.max(by: { $0.value < $1.value })?.key

        // Calculate typical range (25th to 75th percentile)
        let sortedAmounts = categoryTransactions.map { $0.amount }.sorted()
        let lowerBound = sortedAmounts[sortedAmounts.count / 4]
        let upperBound = sortedAmounts[(sortedAmounts.count * 3) / 4]

        // Detect trend (comparing last 2 months vs previous 2 months)
        let trend = detectTrend(category: category, transactions: categoryTransactions)

        return CategoryPattern(
            categoryName: category,
            averageMonthly: avgMonthly,
            peakSpendingDay: peakDay,
            typicalRange: lowerBound...upperBound,
            trend: trend
        )
    }

    // MARK: - Anomaly Detection

    /// Detects unusual spending compared to historical patterns
    static func detectAnomalies(
        transaction: Transaction,
        historicalTransactions: [Transaction]
    ) -> SpendingAnomaly? {
        guard transaction.amount > 0 else { return nil }

        let category = transaction.category.first ?? "Uncategorized"
        let pattern = categoryPattern(category: category, transactions: historicalTransactions)

        // Check if amount is significantly higher than usual
        if transaction.amount > pattern.typicalRange.upperBound * 2 {
            return SpendingAnomaly(
                transaction: transaction,
                anomalyType: .unusuallyHigh,
                severity: .high,
                message: "This \(category) purchase is \(Int((transaction.amount / pattern.averageMonthly) * 100))% of your typical monthly \(category) spending."
            )
        }

        // Check if spending in this category is happening too frequently
        let recentCategoryTransactions = historicalTransactions.filter {
            $0.category.first == category &&
            $0.date >= Calendar.current.date(byAdding: .day, value: -7, to: Date())!
        }

        if recentCategoryTransactions.count > 10 {
            return SpendingAnomaly(
                transaction: transaction,
                anomalyType: .tooFrequent,
                severity: .medium,
                message: "You've made \(recentCategoryTransactions.count) \(category) purchases in the past week, higher than usual."
            )
        }

        return nil
    }

    // MARK: - Cash Flow Prediction

    /// Predicts cash flow for the next N days based on patterns
    static func predictCashFlow(
        transactions: [Transaction],
        accounts: [BankAccount],
        daysAhead: Int = 7
    ) -> CashFlowPrediction {
        let currentCash = accounts
            .filter { $0.isDepository }
            .compactMap { $0.availableBalance ?? $0.currentBalance }
            .reduce(0, +)

        // Predict upcoming bills based on recurring transaction patterns
        let upcomingExpenses = predictUpcomingExpenses(
            transactions: transactions,
            daysAhead: daysAhead
        )

        let totalExpected = upcomingExpenses.map { $0.amount }.reduce(0, +)
        let projectedBalance = currentCash - totalExpected

        return CashFlowPrediction(
            currentBalance: currentCash,
            upcomingExpenses: upcomingExpenses,
            projectedBalance: projectedBalance,
            daysAhead: daysAhead,
            riskLevel: projectedBalance < 100 ? .high : projectedBalance < 500 ? .medium : .low
        )
    }

    // MARK: - Private Helpers

    private static func monthsSpanned(transactions: [Transaction]) -> Int {
        guard let oldest = transactions.map({ $0.date }).min(),
              let newest = transactions.map({ $0.date }).max() else {
            return 1
        }
        return max(Calendar.current.dateComponents([.month], from: oldest, to: newest).month ?? 1, 1)
    }

    private static func detectTrend(category: String, transactions: [Transaction]) -> SpendingTrend {
        let now = Date()
        let twoMonthsAgo = Calendar.current.date(byAdding: .month, value: -2, to: now)!
        let fourMonthsAgo = Calendar.current.date(byAdding: .month, value: -4, to: now)!

        let recentSpending = transactions.filter { $0.date >= twoMonthsAgo }
            .map { $0.amount }.reduce(0, +)

        let olderSpending = transactions.filter { $0.date >= fourMonthsAgo && $0.date < twoMonthsAgo }
            .map { $0.amount }.reduce(0, +)

        guard olderSpending > 0 else { return .stable }

        let changePercent = ((recentSpending - olderSpending) / olderSpending) * 100

        if changePercent > 20 {
            return .increasing
        } else if changePercent < -20 {
            return .decreasing
        } else {
            return .stable
        }
    }

    private static func predictUpcomingExpenses(
        transactions: [Transaction],
        daysAhead: Int
    ) -> [PredictedExpense] {
        // Find recurring transactions (same merchant, similar amounts, regular intervals)
        var recurringExpenses: [PredictedExpense] = []

        // Group by merchant
        let merchantGroups = Dictionary(grouping: transactions) { transaction in
            transaction.merchantName ?? transaction.name
        }

        for (merchant, merchantTransactions) in merchantGroups {
            guard merchantTransactions.count >= 2 else { continue }

            // Calculate average days between transactions
            let sortedDates = merchantTransactions.map { $0.date }.sorted()
            var intervals: [Int] = []

            for i in 1..<sortedDates.count {
                let days = Calendar.current.dateComponents([.day], from: sortedDates[i-1], to: sortedDates[i]).day ?? 0
                intervals.append(days)
            }

            guard !intervals.isEmpty else { continue }

            let avgInterval = Double(intervals.reduce(0, +)) / Double(intervals.count)
            let avgAmount = merchantTransactions.map { $0.amount }.reduce(0, +) / Double(merchantTransactions.count)

            // Check if recurring (interval is consistent, typically monthly ~30 days)
            let isRecurring = (25...35).contains(Int(avgInterval))

            if isRecurring, let lastDate = sortedDates.last {
                let nextExpectedDate = Calendar.current.date(byAdding: .day, value: Int(avgInterval), to: lastDate)!

                // Only include if within prediction window
                let daysUntil = Calendar.current.dateComponents([.day], from: Date(), to: nextExpectedDate).day ?? 999
                if daysUntil >= 0 && daysUntil <= daysAhead {
                    recurringExpenses.append(
                        PredictedExpense(
                            merchantName: merchant,
                            amount: avgAmount,
                            expectedDate: nextExpectedDate,
                            confidence: intervals.count >= 3 ? .high : .medium,
                            category: merchantTransactions.first?.category.first ?? "Unknown"
                        )
                    )
                }
            }
        }

        return recurringExpenses.sorted { $0.expectedDate < $1.expectedDate }
    }
}

// MARK: - Supporting Types

struct MerchantPattern {
    let merchantName: String
    let averageAmount: Double
    let frequency: Double // Transactions per month
    let lastVisit: Date?
    let totalSpent: Double
}

struct CategoryPattern {
    let categoryName: String
    let averageMonthly: Double
    let peakSpendingDay: Int? // Day of month when most spending occurs
    let typicalRange: ClosedRange<Double>
    let trend: SpendingTrend
}

enum SpendingTrend: String {
    case increasing = "Increasing"
    case stable = "Stable"
    case decreasing = "Decreasing"
}

struct SpendingAnomaly {
    let transaction: Transaction
    let anomalyType: AnomalyType
    let severity: AnomalySeverity
    let message: String
}

enum AnomalyType {
    case unusuallyHigh
    case tooFrequent
    case newMerchant
    case outOfPattern
}

enum AnomalySeverity {
    case low
    case medium
    case high
}

struct CashFlowPrediction {
    let currentBalance: Double
    let upcomingExpenses: [PredictedExpense]
    let projectedBalance: Double
    let daysAhead: Int
    let riskLevel: RiskLevel

    enum RiskLevel {
        case low
        case medium
        case high

        var message: String {
            switch self {
            case .low:
                return "You're in good shape for the next week"
            case .medium:
                return "Watch your spending carefully"
            case .high:
                return "Risk of overdraft - consider moving money"
            }
        }
    }
}

struct PredictedExpense {
    let merchantName: String
    let amount: Double
    let expectedDate: Date
    let confidence: Confidence
    let category: String

    enum Confidence {
        case high
        case medium
        case low

        var description: String {
            switch self {
            case .high: return "Very likely"
            case .medium: return "Likely"
            case .low: return "Possible"
            }
        }
    }
}
