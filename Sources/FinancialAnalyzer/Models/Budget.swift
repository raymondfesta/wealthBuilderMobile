import Foundation
import SwiftData

/// Represents a budget for a specific spending category
@Model
final class Budget {
    var id: String
    var categoryName: String
    var monthlyLimit: Double
    var currentSpent: Double
    var month: Date // First day of the month this budget applies to
    var isAutoGenerated: Bool // True if generated from spending patterns
    var createdAt: Date
    var updatedAt: Date

    // Computed properties
    var remaining: Double {
        return max(monthlyLimit - currentSpent, 0)
    }

    var percentUsed: Double {
        guard monthlyLimit > 0 else { return 0 }
        return (currentSpent / monthlyLimit) * 100
    }

    var isOverBudget: Bool {
        return currentSpent > monthlyLimit
    }

    var overageAmount: Double {
        return max(currentSpent - monthlyLimit, 0)
    }

    var status: BudgetStatus {
        let percent = percentUsed
        if isOverBudget {
            return .exceeded
        } else if percent >= 90 {
            return .warning
        } else if percent >= 75 {
            return .caution
        } else {
            return .onTrack
        }
    }

    init(
        id: String = UUID().uuidString,
        categoryName: String,
        monthlyLimit: Double,
        currentSpent: Double = 0,
        month: Date = Date().startOfMonth,
        isAutoGenerated: Bool = false,
        createdAt: Date = Date(),
        updatedAt: Date = Date()
    ) {
        self.id = id
        self.categoryName = categoryName
        self.monthlyLimit = monthlyLimit
        self.currentSpent = currentSpent
        self.month = month
        self.isAutoGenerated = isAutoGenerated
        self.createdAt = createdAt
        self.updatedAt = updatedAt
    }

    /// Updates the spent amount for this budget
    func addSpending(_ amount: Double) {
        currentSpent += amount
        updatedAt = Date()
    }

    /// Resets the budget for a new month
    func resetForNewMonth(newMonth: Date) {
        self.month = newMonth.startOfMonth
        self.currentSpent = 0
        self.updatedAt = Date()
    }
}

enum BudgetStatus: String, Codable {
    case onTrack = "On Track"
    case caution = "Approaching Limit"
    case warning = "Near Limit"
    case exceeded = "Over Budget"

    var color: String {
        switch self {
        case .onTrack:
            return "green"
        case .caution:
            return "yellow"
        case .warning:
            return "orange"
        case .exceeded:
            return "red"
        }
    }

    var iconName: String {
        switch self {
        case .onTrack:
            return "checkmark.circle.fill"
        case .caution:
            return "exclamationmark.triangle.fill"
        case .warning:
            return "exclamationmark.circle.fill"
        case .exceeded:
            return "xmark.circle.fill"
        }
    }
}

// Helper extension for Date
extension Date {
    var startOfMonth: Date {
        let calendar = Calendar.current
        let components = calendar.dateComponents([.year, .month], from: self)
        return calendar.date(from: components) ?? self
    }

    var endOfMonth: Date {
        let calendar = Calendar.current
        guard let nextMonth = calendar.date(byAdding: .month, value: 1, to: startOfMonth),
              let lastDay = calendar.date(byAdding: .day, value: -1, to: nextMonth) else {
            return self
        }
        return lastDay
    }

    var daysRemainingInMonth: Int {
        let calendar = Calendar.current
        return calendar.dateComponents([.day], from: self, to: endOfMonth).day ?? 0
    }
}
